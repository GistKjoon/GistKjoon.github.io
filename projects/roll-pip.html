import React, { useState, useEffect, useRef } from 'react';

function WeeklyGoalApp() {
  // 상태 정의
  const [goals, setGoals] = useState([]);  // 목표 리스트: {id, text, color, active, createdAt}
  const [records, setRecords] = useState({});  // 완료 기록: { goalId: [날짜 문자열 목록] }
  const [theme, setTheme] = useState('light');  // 'light' 또는 'dark'
  const [viewMode, setViewMode] = useState('week');  // 'week' (주간) 또는 'month' (월간)
  const [currentDate, setCurrentDate] = useState(() => {
    // 현재 주의 월요일 날짜로 초기화
    const now = new Date();
    const day = now.getDay();              // 0: 일요일, 1: 월요일, ...
    const diff = (day + 6) % 7;           // 월요일 기준 요일 오프셋 (월요일->0, ... 일요일->6)
    now.setDate(now.getDate() - diff);
    now.setHours(0, 0, 0, 0);
    return now;
  });
  const [editingGoal, setEditingGoal] = useState(null);   // 편집 중인 목표 (없으면 null, 신규 추가 시 {id: null, ...})
  const [showSettings, setShowSettings] = useState(false); // 설정 모달 표시 여부

  // ref 정의
  const nextIdRef = useRef(1);            // 새로운 목표 ID 생성용
  const fileInputRef = useRef(null);      // 파일 입력 요소 ref (JSON 가져오기)
  const touchStartX = useRef(null);       // 터치 시작 X좌표 저장

  // 컴포넌트 마운트 시 로컬스토리지에서 데이터 불러오기
  useEffect(() => {
    try {
      const stored = localStorage.getItem('weeklyGoalsData');
      if (stored) {
        const data = JSON.parse(stored);
        if (data.goals && data.records) {
          setGoals(data.goals);
          setRecords(data.records);
          // nextId 계산 (기존 목표 중 최대 id + 1)
          let maxId = 0;
          data.goals.forEach(g => { if (g.id > maxId) maxId = g.id; });
          nextIdRef.current = maxId + 1;
        }
        if (data.theme) {
          setTheme(data.theme);
        }
      }
    } catch (e) {
      console.error('Failed to load data:', e);
    }
  }, []);

  // 상태 변경 시 로컬스토리지에 저장
  useEffect(() => {
    const data = { goals, records, theme };
    try {
      localStorage.setItem('weeklyGoalsData', JSON.stringify(data));
    } catch (e) {
      console.error('Failed to save data:', e);
    }
  }, [goals, records, theme]);

  // 다크/라이트 테마 클래스 HTML에 적용
  useEffect(() => {
    if (theme === 'dark') {
      document.documentElement.classList.add('dark');
    } else {
      document.documentElement.classList.remove('dark');
    }
  }, [theme]);

  // 키보드 단축키 (←/→ 주간 이동, N 새 목표 추가)
  useEffect(() => {
    const keyHandler = (e) => {
      const tag = e.target.tagName;
      if (tag === 'INPUT' || tag === 'TEXTAREA') return;  // 입력 중이면 무시
      if (e.key === 'ArrowLeft') {
        e.preventDefault();
        // 이전 주 또는 이전 달
        if (viewMode === 'week') {
          setCurrentDate(date => {
            const d = new Date(date);
            d.setDate(d.getDate() - 7);
            return d;
          });
        } else if (viewMode === 'month') {
          setCurrentDate(date => {
            const d = new Date(date);
            d.setDate(1);
            d.setMonth(d.getMonth() - 1);
            return d;
          });
        }
      } else if (e.key === 'ArrowRight') {
        e.preventDefault();
        // 다음 주 또는 다음 달
        if (viewMode === 'week') {
          setCurrentDate(date => {
            const d = new Date(date);
            d.setDate(d.getDate() + 7);
            return d;
          });
        } else if (viewMode === 'month') {
          setCurrentDate(date => {
            const d = new Date(date);
            d.setDate(1);
            d.setMonth(d.getMonth() + 1);
            return d;
          });
        }
      } else if (e.key.toLowerCase() === 'n') {
        e.preventDefault();
        openAddGoal();
      }
    };
    window.addEventListener('keydown', keyHandler);
    return () => window.removeEventListener('keydown', keyHandler);
  }, [viewMode]);

  // 터치 스와이프 제스처 처리 (모바일 주간 변경)
  const handleTouchStart = (e) => {
    touchStartX.current = e.touches[0].clientX;
  };
  const handleTouchEnd = (e) => {
    if (touchStartX.current === null) return;
    const endX = e.changedTouches[0].clientX;
    const diffX = touchStartX.current - endX;
    const threshold = 50;
    if (diffX > threshold) {
      // 왼쪽으로 스와이프 -> 다음 주/달
      if (viewMode === 'week') {
        setCurrentDate(date => {
          const d = new Date(date);
          d.setDate(d.getDate() + 7);
          return d;
        });
      } else if (viewMode === 'month') {
        setCurrentDate(date => {
          const d = new Date(date);
          d.setDate(1);
          d.setMonth(d.getMonth() + 1);
          return d;
        });
      }
    } else if (diffX < -threshold) {
      // 오른쪽으로 스와이프 -> 이전 주/달
      if (viewMode === 'week') {
        setCurrentDate(date => {
          const d = new Date(date);
          d.setDate(d.getDate() - 7);
          return d;
        });
      } else if (viewMode === 'month') {
        setCurrentDate(date => {
          const d = new Date(date);
          d.setDate(1);
          d.setMonth(d.getMonth() - 1);
          return d;
        });
      }
    }
    touchStartX.current = null;
  };

  // 날짜를 "YYYY-MM-DD" 문자열로 포맷하는 유틸리티
  const formatDate = (date) => {
    const y = date.getFullYear();
    const m = ('0' + (date.getMonth() + 1)).slice(-2);
    const d = ('0' + date.getDate()).slice(-2);
    return `${y}-${m}-${d}`;
  };

  // 주간 날짜 배열 (월~일) 생성
  const getWeekDates = (refDate) => {
    const d = new Date(refDate);
    const day = d.getDay();
    const diff = (day + 6) % 7;
    d.setDate(d.getDate() - diff);
    d.setHours(0, 0, 0, 0);
    const week = [];
    for (let i = 0; i < 7; i++) {
      const newD = new Date(d);
      newD.setDate(d.getDate() + i);
      week.push(newD);
    }
    return week;
  };

  // 월간 달력 날짜 배열 생성 (표시용 셀 포함)
  const getMonthDays = (refDate) => {
    const year = refDate.getFullYear();
    const month = refDate.getMonth();
    const first = new Date(year, month, 1);
    const last = new Date(year, month + 1, 0);
    const daysInMonth = last.getDate();
    // 월간 달력 시작을 해당 월 첫째주의 월요일로 맞춤
    const startOffset = (first.getDay() + 6) % 7;  // 1일의 요일 (월요일 기준 오프셋)
    const totalCells = Math.ceil((startOffset + daysInMonth) / 7) * 7;
    const startDate = new Date(first);
    startDate.setDate(first.getDate() - startOffset);
    const grid = [];
    for (let i = 0; i < totalCells; i++) {
      const cur = new Date(startDate);
      cur.setDate(startDate.getDate() + i);
      grid.push(cur);
    }
    return grid;
  };

  // 테마 토글 (다크/라이트)
  const toggleTheme = () => {
    setTheme(prev => (prev === 'dark' ? 'light' : 'dark'));
  };

  // 목표 추가/편집 모달 열기
  const openAddGoal = () => {
    setEditingGoal({ id: null, text: '', color: 'gray', active: true });
  };
  const openEditGoal = (goal) => {
    setEditingGoal({ ...goal });
  };
  const closeModal = () => {
    setEditingGoal(null);
    setShowSettings(false);
  };

  // 목표 저장 (추가 또는 수정)
  const saveGoal = () => {
    if (!editingGoal) return;
    const { id, text, color, active } = editingGoal;
    if (text.trim() === '') {
      alert('목표 내용을 입력해주세요.');
      return;
    }
    if (id == null) {
      // 새 목표 추가
      const newGoal = {
        id: nextIdRef.current,
        text: text.trim(),
        color,
        active: true,
        createdAt: formatDate(new Date())
      };
      nextIdRef.current += 1;
      setGoals(prev => [...prev, newGoal]);
      // 완료 기록 초기화
      setRecords(prev => ({ ...prev, [newGoal.id]: [] }));
    } else {
      // 기존 목표 편집 저장
      setGoals(prev => prev.map(g => (g.id === id ? { ...g, text: text.trim(), color, active } : g)));
    }
    setEditingGoal(null);
  };

  // 목표 삭제
  const deleteGoal = () => {
    if (!editingGoal || editingGoal.id == null) {
      setEditingGoal(null);
      return;
    }
    if (!window.confirm('정말 삭제하시겠습니까?')) {
      return;
    }
    const goalId = editingGoal.id;
    setGoals(prev => prev.filter(g => g.id !== goalId));
    setRecords(prev => {
      const newRec = { ...prev };
      delete newRec[goalId];
      return newRec;
    });
    setEditingGoal(null);
  };

  // 목표 활성/비활성 토글
  const toggleGoalActive = (goalId) => {
    setGoals(prev => prev.map(g => (g.id === goalId ? { ...g, active: !g.active } : g)));
  };

  // 목표 완료 체크 토글 (체크박스)
  const toggleComplete = (goalId, dateStr) => {
    setRecords(prev => {
      const goalRecs = prev[goalId] || [];
      let newRecords = [...goalRecs];
      if (newRecords.includes(dateStr)) {
        // 체크 해제
        newRecords = newRecords.filter(d => d !== dateStr);
      } else {
        // 체크
        newRecords.push(dateStr);
      }
      return { ...prev, [goalId]: newRecords };
    });
    // 햅틱 피드백 (지원 기기에서만)
    if (navigator.vibrate) {
      navigator.vibrate(50);
    }
  };

  // JSON 데이터 가져오기
  const importData = (e) => {
    const file = e.target.files && e.target.files[0];
    if (!file) return;
    file.text().then(jsonStr => {
      try {
        const data = JSON.parse(jsonStr);
        if (data.goals && data.records) {
          setGoals(data.goals);
          setRecords(data.records);
          let maxId = 0;
          data.goals.forEach(g => { if (g.id > maxId) maxId = g.id; });
          nextIdRef.current = maxId + 1;
        }
        if (data.theme) {
          setTheme(data.theme);
        }
        alert('데이터를 성공적으로 불러왔습니다.');
      } catch (err) {
        alert('JSON 파일 형식이 올바르지 않습니다.');
      }
    });
    e.target.value = '';  // 동일 파일 다시 선택할 수 있도록 초기화
  };

  // JSON 데이터 내보내기
  const exportData = () => {
    const data = { goals, records, theme };
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'weekly_goals_backup.json';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

  // 파생 데이터 계산
  const activeGoals = goals.filter(g => g.active);
  const inactiveGoals = goals.filter(g => !g.active);

  const weekDates = getWeekDates(currentDate);
  const weekStart = weekDates[0];
  const weekEnd = weekDates[6];
  const weekRangeStr = 
    `${weekStart.getFullYear()}년 ${weekStart.getMonth() + 1}월 ${weekStart.getDate()}일 ~ ` +
    `${weekEnd.getMonth() + 1}월 ${weekEnd.getDate()}일`;

  const monthDays = getMonthDays(currentDate);
  const monthYearStr = `${currentDate.getFullYear()}년 ${currentDate.getMonth() + 1}월`;

  // 주간 완료 통계 계산
  let totalTasksWeek = 0;
  let completedTasksWeek = 0;
  const dailyCompleted = {};
  const dailyTotal = {};
  activeGoals.forEach(goal => {
    weekDates.forEach(day => {
      const dayStr = formatDate(day);
      // 해당 날짜에 목표가 존재했는지 확인 (생성 이전이면 제외)
      if (goal.createdAt && dayStr < goal.createdAt) return;
      dailyTotal[dayStr] = (dailyTotal[dayStr] || 0) + 1;
      totalTasksWeek += 1;
      const done = records[goal.id]?.includes(dayStr);
      if (done) {
        dailyCompleted[dayStr] = (dailyCompleted[dayStr] || 0) + 1;
        completedTasksWeek += 1;
      } else {
        dailyCompleted[dayStr] = dailyCompleted[dayStr] || 0;
      }
    });
  });
  const completionRate = totalTasksWeek > 0 ? Math.floor((completedTasksWeek * 100) / totalTasksWeek) : 0;

  // 목표 스트릭 계산 (현재 연속일 및 최고 기록)
  let currentStreak = 0;
  let bestStreak = 0;
  if (activeGoals.length > 0) {
    // 현재 활성 목표들의 추적 시작일 (가장 오래된 생성일)
    let startTrackingDate = new Date();
    activeGoals.forEach(goal => {
      const created = goal.createdAt ? new Date(goal.createdAt) : new Date();
      if (created < startTrackingDate) {
        startTrackingDate = created;
      }
    });
    const todayStr = formatDate(new Date());
    let streakCount = 0;
    for (let d = new Date(startTrackingDate); formatDate(d) <= todayStr; d.setDate(d.getDate() + 1)) {
      const dayStr = formatDate(d);
      // 해당 일자에 존재하는 활성 목표들
      const tasksForDay = activeGoals.filter(g => !g.createdAt || dayStr >= g.createdAt);
      if (tasksForDay.length === 0) {
        // 할 목표가 없었던 날은 스트릭 계산에서 제외
        continue;
      }
      const allDone = tasksForDay.every(g => records[g.id]?.includes(dayStr));
      if (allDone) {
        streakCount += 1;
      } else {
        if (streakCount > bestStreak) bestStreak = streakCount;
        streakCount = 0;
      }
    }
    currentStreak = streakCount;
    if (streakCount > bestStreak) {
      bestStreak = streakCount;
    }
  }

  // 체크박스 색상 클래스 (Tailwind accent-*)
  const accentClass = {
    red: 'accent-red-500',
    orange: 'accent-orange-500',
    yellow: 'accent-yellow-500',
    green: 'accent-green-500',
    blue: 'accent-blue-500',
    purple: 'accent-purple-500',
    gray: 'accent-gray-500'
  };
  // 색상 선택 버튼 클래스 (배경색)
  const colorList = ['red', 'orange', 'yellow', 'green', 'blue', 'purple', 'gray'];
  const bgClasses = ['bg-red-500', 'bg-orange-500', 'bg-yellow-500', 'bg-green-500', 'bg-blue-500', 'bg-purple-500', 'bg-gray-500'];

  return (
    <div className={theme === 'dark' ? 'dark' : ''} onTouchStart={handleTouchStart} onTouchEnd={handleTouchEnd}>
      <div className="min-h-screen bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-gray-100 transition-colors duration-300 flex flex-col">
        {/* 헤더 */}
        <header className="flex items-center justify-between p-4 border-b border-gray-300 dark:border-gray-700">
          {/* 뷰 모드 탭 (주간/월간) */}
          <div className="flex items-center space-x-2">
            <button 
              className={`px-3 py-1 rounded ${viewMode === 'week' ? 'bg-gray-300 dark:bg-gray-700 font-bold' : 'bg-gray-200 dark:bg-gray-800'}`}
              onClick={() => setViewMode('week')}
            >
              주간
            </button>
            <button 
              className={`px-3 py-1 rounded ${viewMode === 'month' ? 'bg-gray-300 dark:bg-gray-700 font-bold' : 'bg-gray-200 dark:bg-gray-800'}`}
              onClick={() => setViewMode('month')}
            >
              월간
            </button>
          </div>
          {/* 테마 토글 & 설정 & 로고 */}
          <div className="flex items-center space-x-3">
            <button onClick={toggleTheme} className="text-xl">
              {theme === 'dark' ? '🌙' : '☀️'}
            </button>
            <button onClick={() => setShowSettings(true)} className="text-xl">⚙️</button>
          </div>
        </header>

        {/* 메인 콘텐츠 */}
        <main className="flex-1 p-4 overflow-auto">
          {viewMode === 'week' ? (
            // 주간 화면
            <div>
              {/* 주간 내비게이션 (이전/다음 주) */}
              <div className="flex items-center justify-center mb-2 space-x-4">
                <button onClick={() => setCurrentDate(d => { const nd = new Date(d); nd.setDate(d.getDate() - 7); return nd; })} className="px-2">◀</button>
                <span className="font-medium">{weekRangeStr}</span>
                <button onClick={() => setCurrentDate(d => { const nd = new Date(d); nd.setDate(d.getDate() + 7); return nd; })} className="px-2">▶</button>
              </div>
              {/* 주간 목표 보드 */}
              <div className="grid grid-cols-1 md:grid-cols-7 gap-4">
                {weekDates.map(date => {
                  const dayLabel = ['일', '월', '화', '수', '목', '금', '토'][date.getDay()];
                  const monthDay = `${date.getMonth() + 1}/${date.getDate()}`;
                  const dateStr = formatDate(date);
                  return (
                    <div key={dateStr} className="border border-gray-300 dark:border-gray-700 rounded p-2 flex flex-col">
                      <div className="mb-1 font-semibold">
                        {dayLabel}{' '}
                        <span className="text-sm text-gray-600 dark:text-gray-400">{monthDay}</span>
                      </div>
                      {activeGoals.map(goal => {
                        // 목표 생성 이전 날짜는 표시 건너뜀
                        if (goal.createdAt && dateStr < goal.createdAt) return null;
                        const checked = records[goal.id]?.includes(dateStr) || false;
                        return (
                          <label key={goal.id} className="flex items-center mb-1">
                            <input
                              type="checkbox"
                              checked={checked}
                              onChange={() => toggleComplete(goal.id, dateStr)}
                              className={`mr-2 ${accentClass[goal.color] || 'accent-blue-500'} rounded`}
                            />
                            <span className="flex-1">{goal.text}</span>
                          </label>
                        );
                      })}
                    </div>
                  );
                })}
              </div>
              {/* 주간 통계 섹션 */}
              <div className="mt-6 p-4 bg-gray-200 dark:bg-gray-800 rounded">
                {/* 전체 완료율 */}
                <div className="mb-2 font-semibold">주간 완료율: {completionRate}%</div>
                <div className="w-full bg-gray-300 dark:bg-gray-700 rounded-full h-3 mb-4">
                  <div className="bg-green-500 h-3 rounded-full" style={{ width: `${completionRate}%` }} />
                </div>
                {/* 일별 완료 바차트 */}
                <div className="mb-4">
                  <div className="flex justify-between items-end">
                    {weekDates.map(date => {
                      const dateStr = formatDate(date);
                      const doneCount = dailyCompleted[dateStr] || 0;
                      const totCount = dailyTotal[dateStr] || 0;
                      const percent = totCount ? doneCount / totCount : 0;
                      const barHeight = Math.round(percent * 50) || 2;  // 최대 50px 높이
                      const label = ['월', '화', '수', '목', '금', '토', '일'][(date.getDay() + 6) % 7];
                      return (
                        <div key={dateStr} className="flex flex-col items-center" style={{ width: '14%' }}>
                          <div className="bg-blue-500 opacity-80" style={{ height: `${barHeight}px`, width: '8px' }} />
                          <div className="mt-1 text-xs">{label}</div>
                        </div>
                      );
                    })}
                  </div>
                </div>
                {/* 스트릭 정보 */}
                <div className="text-sm">
                  현재 연속 달성: {currentStreak}일, 최고 연속: {bestStreak}일
                </div>
              </div>
              {/* 비활성화된 목표 목록 */}
              {inactiveGoals.length > 0 && (
                <div className="mt-6 p-4 bg-gray-100 dark:bg-gray-800 rounded">
                  <div className="font-semibold mb-2">비활성화된 목표</div>
                  {inactiveGoals.map(goal => (
                    <div key={goal.id} className="flex items-center justify-between text-sm mb-1">
                      <span className="line-through opacity-70">{goal.text}</span>
                      <button onClick={() => toggleGoalActive(goal.id)} className="text-blue-500 hover:underline">활성화</button>
                    </div>
                  ))}
                </div>
              )}
            </div>
          ) : (
            // 월간 화면
            <div>
              {/* 월간 내비게이션 (이전/다음 달) */}
              <div className="flex items-center justify-center mb-2 space-x-4">
                <button onClick={() => setCurrentDate(d => { const nd = new Date(d); nd.setDate(1); nd.setMonth(d.getMonth() - 1); return nd; })} className="px-2">◀</button>
                <span className="font-medium">{monthYearStr}</span>
                <button onClick={() => setCurrentDate(d => { const nd = new Date(d); nd.setDate(1); nd.setMonth(d.getMonth() + 1); return nd; })} className="px-2">▶</button>
              </div>
              {/* 월간 달력 */}
              <div className="grid grid-cols-7 gap-1 text-center text-sm">
                {/* 요일 헤더 */}
                {['월', '화', '수', '목', '금', '토', '일'].map((d, i) => (
                  <div key={i} className="font-semibold mb-1">{d}</div>
                ))}
                {/* 날짜 셀 */}
                {monthDays.map((date, idx) => {
                  const dateStr = formatDate(date);
                  const inMonth = (date.getMonth() === currentDate.getMonth());
                  // 완료 개수/전체 개수 계산
                  let dayTotal = 0;
                  let dayDone = 0;
                  activeGoals.forEach(goal => {
                    if (goal.createdAt && dateStr < goal.createdAt) return;
                    const todayStr = formatDate(new Date());
                    if (dateStr > todayStr) return;  // 오늘 이후 날짜는 계산 생략
                    dayTotal += 1;
                    if (records[goal.id]?.includes(dateStr)) {
                      dayDone += 1;
                    }
                  });
                  const percent = dayTotal ? dayDone / dayTotal : 0;
                  // 셀 배경 색상 (달성률에 따라)
                  let cellClass = '';
                  if (!inMonth) {
                    cellClass = 'bg-gray-200 dark:bg-gray-700';
                  } else if (percent === 1) {
                    cellClass = 'bg-green-500';
                  } else if (percent >= 0.5) {
                    cellClass = 'bg-green-300';
                  } else if (percent > 0) {
                    cellClass = 'bg-yellow-300';
                  } else {
                    cellClass = 'bg-gray-300 dark:bg-gray-600';
                  }
                  return (
                    <div
                      key={idx}
                      className={`aspect-square flex items-center justify-center ${cellClass} ${inMonth ? '' : 'opacity-50'}`}
                      onClick={() => {
                        if (inMonth) {
                          setCurrentDate(date);
                          setViewMode('week');
                        }
                      }}
                    >
                      <span>{date.getDate()}</span>
                    </div>
                  );
                })}
              </div>
              {/* 스트릭 정보 (월간 화면 하단) */}
              <div className="mt-4 text-sm text-center">
                현재 연속 달성: {currentStreak}일, 최고 연속: {bestStreak}일
              </div>
            </div>
          )}
        </main>

        {/* 하단 모바일 내비게이션 */}
        <nav className="md:hidden fixed bottom-0 left-0 right-0 bg-white dark:bg-gray-800 border-t border-gray-300 dark:border-gray-700">
          <div className="flex justify-around text-sm text-gray-800 dark:text-gray-100">
            <button onClick={() => setViewMode('week')} className="py-2 flex flex-col items-center">
              <span className="text-xl">🏠</span>
              <span>주간</span>
            </button>
            <button onClick={openAddGoal} className="py-2 flex flex-col items-center">
              <span className="text-xl">➕</span>
              <span>추가</span>
            </button>
            <button onClick={() => setViewMode('month')} className="py-2 flex flex-col items-center">
              <span className="text-xl">🗓️</span>
              <span>월간</span>
            </button>
            <button onClick={() => setShowSettings(true)} className="py-2 flex flex-col items-center">
              <span className="text-xl">⚙️</span>
              <span>설정</span>
            </button>
          </div>
        </nav>

        {/* 목표 추가/편집 모달 */}
        {editingGoal && (
          <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-10">
            <div className="bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 p-6 rounded shadow max-w-xs w-full">
              <div className="flex justify-between items-center mb-4">
                <h2 className="text-lg font-semibold">
                  {editingGoal.id == null ? '목표 추가' : '목표 수정'}
                </h2>
                <button onClick={closeModal} className="text-2xl font-bold">&times;</button>
              </div>
              <div className="mb-3">
                <input
                  type="text"
                  className="w-full p-2 rounded border border-gray-300 dark:border-gray-600 bg-gray-50 dark:bg-gray-700"
                  placeholder="목표 이름"
                  value={editingGoal.text}
                  onChange={(e) => setEditingGoal({ ...editingGoal, text: e.target.value })}
                />
              </div>
              <div className="mb-3">
                <label className="block mb-1">색상 라벨:</label>
                <div className="flex space-x-2">
                  {colorList.map((col, idx) => (
                    <button
                      key={col}
                      className={`w-6 h-6 rounded-full ${bgClasses[idx]} ${editingGoal.color === col ? '' : 'opacity-50'}`}
                      onClick={() => setEditingGoal({ ...editingGoal, color: col })}
                    />
                  ))}
                </div>
              </div>
              <div className="mb-4">
                <label className="inline-flex items-center">
                  <input
                    type="checkbox"
                    checked={editingGoal.active}
                    onChange={(e) => setEditingGoal({ ...editingGoal, active: e.target.checked })}
                    className="mr-2"
                  />
                  활성 상태
                </label>
              </div>
              <div className="flex justify-between">
                {editingGoal.id != null ? (
                  <button onClick={deleteGoal} className="text-red-500">삭제</button>
                ) : <span></span>}
                <div className="space-x-2">
                  <button onClick={closeModal} className="px-3 py-1 bg-gray-300 dark:bg-gray-700 rounded">취소</button>
                  <button onClick={saveGoal} className="px-3 py-1 bg-blue-500 text-white rounded">
                    {editingGoal.id == null ? '추가' : '저장'}
                  </button>
                </div>
              </div>
            </div>
          </div>
        )}

        {/* 설정 모달 */}
        {showSettings && (
          <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-10">
            <div className="bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 p-6 rounded shadow max-w-xs w-full">
              <div className="flex justify-between items-center mb-4">
                <h2 className="text-lg font-semibold">설정</h2>
                <button onClick={closeModal} className="text-2xl font-bold">&times;</button>
              </div>
              <div className="mb-4">
                <label className="mr-2">테마:</label>
                <button onClick={toggleTheme} className="px-3 py-1 rounded bg-gray-200 dark:bg-gray-700">
                  {theme === 'dark' ? '라이트 모드로' : '다크 모드로'}
                </button>
              </div>
              <div className="mb-4">
                <div className="mb-2">데이터 내보내기/가져오기:</div>
                <div className="flex space-x-2">
                  <button onClick={exportData} className="px-3 py-1 bg-gray-300 dark:bg-gray-700 rounded">내보내기</button>
                  <button onClick={() => fileInputRef.current.click()} className="px-3 py-1 bg-gray-300 dark:bg-gray-700 rounded">가져오기</button>
                  <input
                    type="file"
                    accept="application/json"
                    ref={fileInputRef}
                    onChange={importData}
                    style={{ display: 'none' }}
                  />
                </div>
              </div>
              <div className="text-xs text-gray-600 dark:text-gray-400">
                ※ 가져오기를 하면 현재 데이터가 덮어쓰여집니다.
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  );
}

export default WeeklyGoalApp;
